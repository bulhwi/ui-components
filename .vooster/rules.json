{
  "rules": [
    {
      "type": "prd",
      "content": "# React/Next.js 내부 UI 컴포넌트 라이브러리 PRD\n\n## 1. 제품 개요\n사내 프런트엔드 개발자가 프로젝트를 시작하거나 기존 프로젝트를 확장할 때, 일관성 있고 검증된 UI 컴포넌트를 빠르게 가져다 쓸 수 있는 React·Next.js·TypeScript 기반 내부 전용 라이브러리다. Storybook을 문서·프리뷰 허브로 사용하며, 다크모드·i18n·반응형을 기본 지원하고 Jest 테스트로 품질을 담보한다. 배포 초기 단계에서는 로컬 링크(monorepo 혹은 `npm link`) 방식으로만 제공한다.\n\n## 2. 목표\n1. 4주 이내 MVP(버튼·인풋·모달·레이아웃 등 필수 6종) 제공\n2. 새로운 사내 프로젝트 세팅 소요 시간을 30% 단축\n3. 컴포넌트 중복 구현 사례 50% 이상 감소\n\n## 3. 핵심 사용자\n- 1–2명의 사내 프런트엔드 개발자(메인)\n- 보조: 디자이너, 풀스택 개발자\n\n## 4. 주요 사용 시나리오\n1. 새 프로젝트 킥오프 시 `yarn link ui-library` 후 표준 컴포넌트 import\n2. Storybook에서 디자인·코드 예시 확인 후 props 조정하여 바로 적용\n\n## 5. 주요 기능 (확정)\n| 분류 | 기능 | 설명 |\n|------|------|------|\n|카탈로그|Storybook 프리뷰|컴포넌트별 실시간 렌더·Docs 패널 자동 생성|\n|테마|다크 모드 스위처|Global 토글 및 ThemeProvider 구현|\n|국제화|i18n 지원|Storybook UI & 데모 텍스트 다국어|\n|품질|Jest + RTL 테스트|유닛 테스트·커버리지 리포트|\n|반응형|뷰포트 컨트롤|스토리북 애드온으로 모바일/태블릿 미리보기|\n\n## 6. 보류 기능 (검토)\n- 접근성 자동 검사 & 리포트\n- 시각적 회귀 테스트(Chromatic)\n- 디자인 토큰 시스템\n\n## 7. 제품 요구사항\n### 기능 요구사항\n1. 모든 컴포넌트는 TypeScript, React 18 기준으로 작성한다.\n2. styled-components 기반 스타일링, ThemeProvider로 다크/라이트 토글.\n3. Storybook 7 이상, Docs & Controls 애드온 필수 설정.\n4. 각 컴포넌트 최소 3개의 Story(기본/변형/Edge)를 작성.\n5. 유닛 테스트 커버리지 80% 이상.\n6. 국제화: 기본 `ko`, `en` JSON 리소스 제공.\n\n### 비기능 요구사항\n1. 사내 네트워크 환경에서만 접근 가능.\n2. 초기 배포: 로컬 링크 방식, CI/CD 없음.\n3. 코드 스타일: ESLint + Prettier + Husky pre-commit.\n\n## 8. 우선순위 로드맵 (4주 스프린트)\n| 주차 | 산출물 |\n|------|---------|\n|1주차|리포지토리·Lint 설정, Storybook 초기 설정, Button, IconButton|\n|2주차|Input(Text, Number), Modal, 다크모드 테마 시스템|\n|3주차|Layout(Header, Footer), i18n 설정, 테스트 작성 강화|\n|4주차|반응형 뷰포트 애드온, 문서화 보강, QA & 내부 베타 배포|\n\n## 9. 성공 지표(KPI)\n- MVP 배포 4주 내 완료 여부\n- Storybook 일간 방문 3회 이상(팀 규모 대비)\n- 신규 프로젝트에서 라이브러리 도입률 80% 이상\n\n## 10. 가정 및 위험\n| 가정 | 대응 전략 |\n|------|-----------|\n|소규모 팀이라 의사 결정 속도가 빠르다|데일리 스탠드업으로 진행 상황 공유|\n|로컬 링크 방식이 초기엔 충분하다|필요 시 GitHub Packages로 단계적 전환|\n|디자이너 리소스 제한|Figma 컴포넌트는 PM이 우선 정리 후 개발자가 반영|\n\n## 11. 승인\n- 작성: Vooster PM Assistant\n- 승인: ______ (캡틴)",
      "writedAt": "2025-08-26T05:41:05.272Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n- **Project Overview**: React, Next.js, TypeScript 기반의 재사용 가능한 내부 UI 컴포넌트 라이브러리 구축. Storybook을 활용한 시각적 문서화 및 프리뷰 환경 제공. 다크 모드, i18n, 반응형 지원, Jest 기반 테스트를 통해 품질 확보. 로컬 링크 배포 방식으로 초기 제공.\n- **Core Technology Stack**: React, Next.js, TypeScript, styled-components, Storybook, Jest를 핵심 기술 스택으로 사용.\n- **Key Technical Objectives**: 4주 이내 MVP 배포, 사내 프로젝트 세팅 시간 30% 단축, 컴포넌트 중복 구현 50% 이상 감소.\n- **Critical Technical Assumptions**: 소규모 팀으로 빠른 의사 결정 가능, 로컬 링크 배포 방식이 초기 단계에 적합, 디자이너 리소스 제한적.\n\n## 2. Tech Stack\n\n| Category          | Technology / Library        | Reasoning (Why it's chosen for this project) |\n| ----------------- | --------------------------- | -------------------------------------------- |\n| UI Framework      | React                       | 컴포넌트 기반 아키텍처, 높은 재사용성 및 생산성 |\n| Server-Side Rendering | Next.js                    | 초기 로딩 속도 개선, SEO 최적화 (향후 확장 고려) |\n| Language          | TypeScript                  | 정적 타입 검사, 코드 안정성 및 유지보수성 향상 |\n| Styling           | styled-components           | 컴포넌트 레벨 스타일링, 테마 지원 용이성 |\n| Documentation & Preview | Storybook                 | 컴포넌트 시각적 문서화, 프리뷰, 개발 환경 제공 |\n| Testing           | Jest                        | 유닛 테스트, 컴포넌트 동작 검증 |\n| Testing Library | @testing-library/react | React 컴포넌트 테스트를 위한 유틸리티 제공 |\n| Linting | ESLint | 코드 스타일 일관성 유지 및 오류 방지 |\n| Formatting | Prettier | 자동 코드 포맷팅으로 코드 가독성 향상 |\n| Git Hooks | Husky | Git 커밋 전 Linting 및 테스트 실행 |\n\n## 3. System Architecture Design\n\n### Top-Level building blocks\n*   **UI 컴포넌트 라이브러리**:\n    *   재사용 가능한 UI 컴포넌트 (Button, Input, Modal, Layout 등)\n    *   styled-components 기반 스타일링\n    *   TypeScript 기반 타입 정의\n*   **Storybook**:\n    *   컴포넌트 문서화 및 프리뷰 환경 제공\n    *   다크 모드, i18n, 반응형 뷰포트 컨트롤 지원\n    *   Docs 애드온, Controls 애드온 활용\n*   **테스팅 환경**:\n    *   Jest 기반 유닛 테스트\n    *   @testing-library/react 활용\n    *   코드 커버리지 리포트 생성\n*   **개발 환경**:\n    *   ESLint, Prettier, Husky 설정\n    *   로컬 링크 배포 방식\n\n### Top-Level Component Interaction Diagram\n\n```mermaid\ngraph LR\n    A[사내 프로젝트] --> B[UI 컴포넌트 라이브러리]\n    B --> C[Storybook]\n    B --> D[Jest 테스트]\n    B --> E[styled-components 테마]\n    B --> F[i18n 리소스]\n```\n\n*   **사내 프로젝트**: UI 컴포넌트 라이브러리를 import하여 사용.\n*   **UI 컴포넌트 라이브러리**: Storybook을 통해 문서화 및 프리뷰 제공, Jest 테스트를 통해 품질 검증.\n*   **styled-components 테마**: 다크 모드 등 테마 관련 스타일 제공.\n*   **i18n 리소스**: 다국어 지원을 위한 JSON 파일 제공.\n\n### Code Organization & Convention\n**Domain-Driven Organization Strategy**\n- **Domain Separation**: 컴포넌트 종류별로 디렉토리 분리 (e.g., `components/button`, `components/input`).\n- **Layer-Based Architecture**: 각 컴포넌트 디렉토리 내에 스타일, 타입, 컴포넌트 파일을 분리 (e.g., `components/button/Button.tsx`, `components/button/Button.styles.ts`, `components/button/Button.types.ts`).\n- **Feature-Based Modules**: 컴포넌트 관련 기능 (테스트, 스토리)을 컴포넌트 디렉토리 내에 포함 (e.g., `components/button/Button.test.tsx`, `components/button/Button.stories.tsx`).\n- **Shared Components**: 공통 타입, 유틸리티 함수 등을 `shared` 디렉토리에 관리.\n\n**Universal File & Folder Structure**\n```\n/\n├── .eslintrc.js           # ESLint 설정\n├── .prettierrc.js          # Prettier 설정\n├── .husky/                # Husky 설정 디렉토리\n│   └── pre-commit         # pre-commit 훅\n├── src/                   # 소스 코드 디렉토리\n│   ├── components/          # UI 컴포넌트 디렉토리\n│   │   ├── button/           # Button 컴포넌트 디렉토리\n│   │   │   ├── Button.tsx      # Button 컴포넌트\n│   │   │   ├── Button.styles.ts # Button 스타일\n│   │   │   ├── Button.types.ts  # Button 타입 정의\n│   │   │   ├── Button.test.tsx   # Button 테스트\n│   │   │   └── Button.stories.tsx# Button 스토리\n│   │   ├── input/            # Input 컴포넌트 디렉토리\n│   │   │   └── ...\n│   │   ├── modal/            # Modal 컴포넌트 디렉토리\n│   │   │   └── ...\n│   │   └── layout/           # Layout 컴포넌트 디렉토리\n│   │       └── ...\n│   ├── styles/             # 전역 스타일 디렉토리\n│   │   ├── theme.ts         # 테마 정의\n│   │   └── global.ts        # 전역 스타일 정의\n│   ├── i18n/                # 국제화 디렉토리\n│   │   ├── en.json          # 영어 리소스\n│   │   └── ko.json          # 한국어 리소스\n│   ├── shared/              # 공유 컴포넌트 및 유틸리티\n│   │   ├── types/           # 공통 타입 정의\n│   │   └── utils/           # 유틸리티 함수\n│   ├── App.tsx              # Next.js App 컴포넌트\n│   └── index.ts             # 컴포넌트 export\n├── .storybook/           # Storybook 설정 디렉토리\n│   ├── main.js            # Storybook 메인 설정\n│   └── preview.js         # Storybook 프리뷰 설정\n├── jest.config.js         # Jest 설정\n├── tsconfig.json          # TypeScript 설정\n├── package.json           # 패키지 설정\n└── README.md              # README 파일\n```\n\n### Data Flow & Communication Patterns\n- **Client-Server Communication**: 해당 없음 (UI 컴포넌트 라이브러리이므로 서버 통신 로직은 포함하지 않음).\n- **Database Interaction**: 해당 없음.\n- **External Service Integration**: 해당 없음.\n- **Real-time Communication**: 해당 없음.\n- **Data Synchronization**: 해당 없음.\n\n## 4. Performance & Optimization Strategy\n*   컴포넌트 불필요한 리렌더링 방지 (`React.memo`, `useCallback`, `useMemo` 활용).\n*   이미지 최적화 (Next.js `Image` 컴포넌트 활용).\n*   코드 스플리팅 (Next.js 기본 지원).\n*   styled-components CSS-in-JS 최적화 (Babel 플러그인 활용).\n\n## 5. Implementation Roadmap & Milestones\n### Phase 1: Foundation (MVP Implementation)\n- **Core Infrastructure**: 리포지토리 설정, ESLint/Prettier 설정, Storybook 초기 설정.\n- **Essential Features**: Button, IconButton, Input(Text, Number), Modal, Layout(Header, Footer) 컴포넌트 구현.\n- **Basic Security**: 해당 없음 (UI 컴포넌트 라이브러리이므로 보안 관련 기능은 포함하지 않음).\n- **Development Setup**: 로컬 링크 방식 배포 설정.\n- **Timeline**: 1~2주차 완료.\n\n### Phase 2: Feature Enhancement\n- **Advanced Features**: 다크 모드 테마 시스템, i18n 설정, 반응형 뷰포트 애드온 설정.\n- **Performance Optimization**: 컴포넌트 성능 최적화.\n- **Enhanced Security**: 해당 없음.\n- **Monitoring Implementation**: 해당 없음.\n- **Timeline**: 3~4주차 완료.\n\n## 6. Risk Assessment & Mitigation Strategies\n### Technical Risk Analysis\n- **Technology Risks**: styled-components의 런타임 오버헤드 발생 가능성.\n    - **Mitigation Strategies**: styled-components Babel 플러그인 적용, 필요 시 CSS Modules로 전환 고려.\n- **Performance Risks**: 컴포넌트 복잡도 증가에 따른 렌더링 성능 저하 가능성.\n    - **Mitigation Strategies**: `React.memo`, `useCallback`, `useMemo` 활용, 불필요한 리렌더링 방지.\n- **Security Risks**: 해당 없음.\n- **Integration Risks**: 해당 없음.\n\n### Project Delivery Risks\n- **Timeline Risks**: 컴포넌트 개발 지연 가능성.\n    - **Contingency Plans**: 우선순위가 낮은 컴포넌트 개발 연기, 외부 라이브러리 활용 검토.\n- **Resource Risks**: 개발자 역량 부족으로 인한 문제 발생 가능성.\n    - **Contingency Plans**: 팀 내 스터디 진행, 외부 전문가 컨설팅.\n- **Quality Risks**: 테스트 부족으로 인한 버그 발생 가능성.\n    - **Contingency Plans**: 테스트 코드 작성 강화, 코드 리뷰 활성화.\n- **Deployment Risks**: 로컬 링크 방식 배포의 불편함.\n    - **Contingency Plans**: GitHub Packages로 단계적 전환 고려.\n",
      "writedAt": "2025-08-26T05:41:05.272Z"
    },
    {
      "type": "guideline",
      "content": "# UI Component Library Code Guidelines\n\n## 1. Project Overview\n\nThis document outlines the coding standards for a reusable internal UI component library built with React, Next.js, and TypeScript. The library utilizes Storybook for visual documentation and previews, supports dark mode, i18n, and responsiveness, and ensures quality through Jest-based testing. The initial deployment is via local linking.\n\nKey architectural decisions include:\n\n*   React for component-based architecture and reusability.\n*   Next.js for server-side rendering and SEO optimization (future consideration).\n*   TypeScript for static typing and improved code maintainability.\n*   styled-components for component-level styling and theme support.\n*   Storybook for component documentation and previewing.\n*   Jest for unit testing and component behavior verification.\n\n## 2. Core Principles\n\n*   **Maintainability**: Write code that is easy to understand, modify, and debug.\n*   **Reusability**: Design components to be generic and adaptable to various contexts.\n*   **Testability**: Ensure components are easily testable with comprehensive unit tests.\n*   **Consistency**: Adhere to consistent coding style and architectural patterns.\n*   **Performance**: Optimize components for efficient rendering and minimal overhead.\n\n## 3. Language-Specific Guidelines\n\n### TypeScript\n\n*   **File Organization**:\n    *   Each component should reside in its own directory under `src/components`.\n    *   Each component directory should contain:\n        *   `Component.tsx`: The React component.\n        *   `Component.styles.ts`: styled-components styles.\n        *   `Component.types.ts`: TypeScript type definitions.\n        *   `Component.test.tsx`: Jest tests.\n        *   `Component.stories.tsx`: Storybook stories.\n*   **Import/Dependency Management**:\n    *   Use absolute imports for internal modules (e.g., `import Button from 'components/button/Button';`).\n    *   Group imports by origin (e.g., libraries, then internal modules).\n    *   Sort imports alphabetically within each group.\n*   **Error Handling**:\n    *   Use TypeScript's type system to prevent errors at compile time.\n    *   Handle potential runtime errors gracefully, using `try...catch` blocks where appropriate.\n    *   Provide informative error messages.\n\n### React\n\n*   **File Organization**: Follow the file structure specified in TypeScript section.\n*   **Component Structure**:\n    *   Use functional components with hooks.\n    *   Separate concerns into smaller, reusable components.\n    *   Use prop types effectively for type safety.\n*   **State Management**:\n    *   Prefer local component state using `useState` for simple cases.\n    *   Avoid global state management solutions initially; consider `useContext` for simple shared state.\n*   **Error Handling**:\n    *   Use `ErrorBoundary` components to catch and handle errors within component trees.\n\n### Next.js\n\n*   **File Organization**:\n    *   Utilize the `pages` directory for route-based components (if needed in the future).\n    *   Place API routes in the `pages/api` directory (if needed in the future).\n    *   Use the `public` directory for static assets.\n*   **Data Fetching**:\n    *   Use `getStaticProps` or `getServerSideProps` for data fetching (if needed in the future).\n*   **Error Handling**:\n    *   Implement custom error pages (`pages/_error.js`).\n\n### styled-components\n\n*   **File Organization**:\n    *   Define styles in separate `Component.styles.ts` files within each component directory.\n    *   Use the `theme.ts` file in the `src/styles` directory to define global theme variables.\n*   **Styling Conventions**:\n    *   Use semantic class names.\n    *   Avoid inline styles.\n    *   Use theme variables for consistent styling across components.\n    *   Use media queries for responsive design.\n\n### Storybook\n\n*   **File Organization**:\n    *   Create stories for each component in the `Component.stories.tsx` file within each component directory.\n*   **Story Conventions**:\n    *   Write at least three stories per component: a basic story, a variation story, and an edge case story.\n    *   Use the `Docs` and `Controls` addons to automatically generate documentation and interactive controls.\n    *   Document each prop and its purpose.\n\n### Jest\n\n*   **File Organization**:\n    *   Create test files for each component in the `Component.test.tsx` file within each component directory.\n*   **Testing Conventions**:\n    *   Write unit tests for all components.\n    *   Aim for 80% test coverage.\n    *   Use `@testing-library/react` for testing React components.\n    *   Test component behavior, not implementation details.\n    *   Mock external dependencies.\n\n## 4. Code Style Rules\n\n### MUST Follow:\n\n*   **Naming Conventions**:\n    *   Components: PascalCase (e.g., `Button`, `Input`).\n    *   Variables/Functions: camelCase (e.g., `handleClick`, `inputValue`).\n    *   Constants: UPPER_SNAKE_CASE (e.g., `DEFAULT_SIZE`).\n    *   Files: PascalCase.tsx/ts (e.g., `Button.tsx`, `Button.styles.ts`).\n    *   Rationale: Improves readability and maintainability.\n*   **Code Formatting**:\n    *   Use Prettier for automatic code formatting.\n    *   Configure Prettier to use consistent indentation, line length, and spacing.\n    *   Rationale: Ensures consistent code style across the project.\n*   **Linting**:\n    *   Use ESLint to enforce code style rules and prevent errors.\n    *   Configure ESLint with recommended React and TypeScript rules.\n    *   Rationale: Helps catch potential issues early and maintain code quality.\n*   **Comments**:\n    *   Write clear and concise comments to explain complex logic or non-obvious code.\n    *   Use JSDoc-style comments for documenting components and functions.\n    *   Rationale: Improves code understanding and maintainability.\n*   **Type Safety**:\n    *   Use TypeScript's type system to define types for all variables, function parameters, and component props.\n    *   Avoid using `any` type unless absolutely necessary.\n    *   Rationale: Prevents type-related errors at runtime and improves code reliability.\n*   **Component Composition**:\n    *   Favor composition over inheritance.\n    *   Create small, reusable components that can be composed together to build more complex UIs.\n    *   Rationale: Promotes code reusability and maintainability.\n*   **State Management**:\n    *   Use local component state (`useState`) for simple state management.\n    *   Consider using `useContext` for sharing state between components.\n    *   Rationale: Keeps state management simple and predictable.\n*   **Error Handling**:\n    *   Use `try...catch` blocks to handle potential runtime errors.\n    *   Use `ErrorBoundary` components to catch and handle errors within component trees.\n    *   Rationale: Prevents application crashes and provides a better user experience.\n*   **Testing**:\n    *   Write unit tests for all components.\n    *   Aim for 80% test coverage.\n    *   Use `@testing-library/react` for testing React components.\n    *   Rationale: Ensures component functionality and prevents regressions.\n\n#### Examples:\n\n```typescript\n// MUST: Consistent naming convention\nconst buttonStyle = styled.button`\n  /* ...styles */\n`;\n\n// MUST: Type definitions for component props\ninterface ButtonProps {\n  label: string;\n  onClick: () => void;\n}\n\nconst Button: React.FC<ButtonProps> = ({ label, onClick }) => {\n  return <button onClick={onClick}>{label}</button>;\n};\n\nexport default Button;\n```\n\n```typescript\n// MUST NOT: Using 'any' type without a valid reason\nlet myVariable: any; // Avoid this\n\n// Instead, define a specific type:\nlet myVariable: string;\n```\n\n### MUST NOT Do:\n\n*   **Direct DOM Manipulation**:\n    *   Avoid directly manipulating the DOM using `document.getElementById` or similar methods.\n    *   Use React's virtual DOM to update the UI.\n    *   Rationale: Violates React's principles and can lead to performance issues.\n*   **Mutating Props**:\n    *   Never directly modify props passed to a component.\n    *   Props should be treated as read-only.\n    *   Rationale: Can lead to unexpected behavior and difficult-to-debug issues.\n*   **Ignoring ESLint/Prettier Warnings/Errors**:\n    *   Always address ESLint and Prettier warnings and errors.\n    *   Rationale: These tools are in place to help you write better code.\n*   **Skipping Tests**:\n    *   Do not skip writing tests for components.\n    *   Rationale: Tests ensure component functionality and prevent regressions.\n*   **Hardcoding Values**:\n    *   Avoid hardcoding values directly in components.\n    *   Use theme variables or configuration files for consistent styling and behavior.\n    *   Rationale: Makes it easier to update values across the application.\n*   **Complex State Management**:\n    *   Avoid introducing complex state management libraries (Redux, MobX) prematurely.\n    *   Start with local component state or `useContext` and only introduce more complex solutions if necessary.\n    *   Rationale: Keeps the application simple and reduces unnecessary complexity.\n*   **Nested Ternary Operators**:\n    *   Avoid deeply nested ternary operators, as they can be hard to read.\n    *   Rationale: Improves code readability and maintainability.\n*   **Long Component Files**:\n    *   Avoid creating very long and complex component files.\n    *   Break down large components into smaller, more manageable sub-components.\n    *   Rationale: Improves code readability and maintainability.\n*   **Over-commenting**:\n    *   Avoid over-commenting. Code should be self-explanatory where possible.\n    *   Rationale: Focus on writing clean, understandable code.\n\n#### Examples:\n\n```typescript\n// MUST NOT: Direct DOM manipulation\nconst handleClick = () => {\n  document.getElementById('myElement').innerHTML = 'Hello'; // Avoid this\n};\n\n// Instead, use React's state management:\nconst [text, setText] = React.useState('Initial Text');\n\nconst handleClick = () => {\n  setText('Hello');\n};\n```\n\n```typescript\n// MUST NOT: Mutating props\nconst MyComponent: React.FC<{ value: string }> = (props) => {\n  props.value = 'New Value'; // Avoid this\n  return <div>{props.value}</div>;\n};\n\n// Instead, create a local state if you need to modify the value:\nconst MyComponent: React.FC<{ initialValue: string }> = (props) => {\n  const [value, setValue] = React.useState(props.initialValue);\n  return <div>{value}</div>;\n};\n```\n\n## 5. Architecture Patterns\n\n*   **Component/Module Structure**:\n    *   Follow the Domain-Driven Organization Strategy.\n    *   Separate components by type (e.g., `components/button`, `components/input`).\n    *   Use a Layer-Based Architecture within each component directory (e.g., `Button.tsx`, `Button.styles.ts`, `Button.types.ts`).\n    *   Include related features (tests, stories) within the component directory (e.g., `Button.test.tsx`, `Button.stories.tsx`).\n    *   Manage shared components and utilities in the `shared` directory.\n*   **Data Flow Patterns**:\n    *   Data flows from parent components to child components via props.\n    *   Child components can communicate with parent components via callbacks passed as props.\n*   **State Management Conventions**:\n    *   Start with local component state using `useState`.\n    *   Consider using `useContext` for sharing state between components.\n    *   Avoid complex state management solutions unless necessary.\n*   **API Design Standards**:\n    *   N/A - No external API\n\n#### Examples:\n\n```typescript\n// MUST: Component directory structure\n// src/components/button/Button.tsx\n// src/components/button/Button.styles.ts\n// src/components/button/Button.types.ts\n// src/components/button/Button.test.tsx\n// src/components/button/Button.stories.tsx\n```\n\n```typescript\n// MUST: Prop drilling\n// Parent component\nconst ParentComponent = () => {\n  const [data, setData] = React.useState('Hello from Parent');\n\n  return <ChildComponent data={data} />;\n};\n\n// Child component\nconst ChildComponent: React.FC<{ data: string }> = ({ data }) => {\n  return <div>{data}</div>;\n};\n```\n",
      "writedAt": "2025-08-26T05:41:05.272Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-08-26T05:41:05.272Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-08-26T05:41:05.272Z"
    }
  ]
}